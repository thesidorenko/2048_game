{"mappings":"A,S,E,C,C,C,E,C,A,M,G,E,E,M,A,G,C,E,E,M,A,E,I,I,E,E,E,A,M,G,E,E,I,C,C,E,C,C,C,E,C,O,C,C,S,E,C,C,C,E,G,C,C,a,C,E,M,A,U,oC,C,S,E,C,C,C,E,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,A,C,E,U,C,E,U,E,C,E,E,Y,C,C,E,U,G,C,E,Q,C,C,C,E,O,c,C,E,E,G,C,E,C,C,S,E,C,C,C,C,C,E,O,G,E,E,S,C,G,G,E,E,G,C,C,S,E,C,E,O,A,S,C,E,G,M,O,C,G,O,E,E,E,I,A,S,C,E,G,A,a,O,Q,A,M,C,C,O,Q,C,E,A,M,C,C,a,C,O,M,I,C,E,E,I,A,S,C,C,C,E,G,G,G,A,U,O,E,O,E,E,K,G,I,E,O,S,C,Q,C,I,C,G,K,C,E,I,G,W,G,E,W,E,C,E,E,W,C,I,A,E,A,Q,G,A,Q,E,O,M,I,C,G,G,A,c,G,2C,I,C,G,O,E,E,K,G,E,I,A,W,M,A,U,wI,G,CCEA,IAAM,EAAQ,SAAS,aAAa,CAAC,eAC/B,EAAc,SAAS,aAAa,CAAC,UACrC,EAAY,SAAS,aAAa,CAAC,eACnC,EAAa,SAAS,aAAa,CAAC,gBACpC,EAAc,SAAS,aAAa,CAAC,iBACrC,EAAe,SAAS,aAAa,CAAC,kBAGxC,EAAa,EAEjB,EAAY,gBAAgB,CAAC,QAAS,WAChC,EAAY,SAAS,CAAC,QAAQ,CAAC,WACjC,EAAY,SAAS,CAAC,MAAM,CAAC,SAC7B,EAAY,SAAS,CAAC,GAAG,CAAC,WAC1B,EAAY,WAAW,CAAG,UAC1B,EAAa,SAAS,CAAC,GAAG,CAAC,UAC3B,EAAW,SAAS,CAAC,GAAG,CAAC,UACzB,EAAY,SAAS,CAAC,GAAG,CAAC,WAG5B,EAAM,KAAK,CAAC,OAAO,CAAC,SAAA,CAApB,EACO,EAAK,OAAO,KACf,EAAK,UAAU,CAAC,aAAa,GAC7B,EAAK,UAAU,IAGjB,EAAM,WAAW,CAAG,CACtB,GAEA,EAAM,aAAa,GAAG,QAAQ,CAAC,IAAI,EAAK,IACxC,EAAM,aAAa,GAAG,QAAQ,CAAC,IAAI,EAAK,GAC1C,GAEA,IAAM,EAAN,WAAM,SAAA,EACQ,CAAY,EADpB,EAAA,IAAA,CAAA,GAEF,IAAI,CAAC,KAAK,CAAG,EAAE,CAEf,IAAK,IAAI,EAAI,EAAG,EA9BD,GA8BiB,IAC9B,IAAI,CAAC,KAAK,CAAC,IAAI,CACb,IAAI,EACF,EACA,EAnCS,EAoCT,KAAK,KAAK,CAAC,EApCF,IAyCf,CAAA,IAAI,CAAC,oBAAoB,CAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAC,CAAA,CAAY,CAA3D,EAIE,OAHA,CAAU,CAAC,EAAK,CAAC,CAAC,CAAG,CAAU,CAAC,EAAK,CAAC,CAAC,EAAI,EAAE,CAC7C,CAAU,CAAC,EAAK,CAAC,CAAC,CAAC,EAAK,CAAC,CAAC,CAAG,EAEtB,CACT,EAAG,EAAE,EAEL,IAAI,CAAC,4BAA4B,CAAG,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAC/D,SAAA,CADF,EACY,OAAC,EAAG,GAAQ,OAAO,E,GAG/B,IAAI,CAAC,iBAAiB,CAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAC,CAAA,CAAY,CAAxD,EAIE,OAHA,CAAU,CAAC,EAAK,CAAC,CAAC,CAAG,CAAU,CAAC,EAAK,CAAC,CAAC,EAAI,EAAE,CAC7C,CAAU,CAAC,EAAK,CAAC,CAAC,CAAC,EAAK,CAAC,CAAC,CAAG,EAEtB,CACT,EAAG,EAAE,EAEL,IAAI,CAAC,yBAAyB,CAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CACzD,SAAA,CADF,EACS,OAAC,EAAG,GAAK,OAAO,E,E,CAjCvB,OAAA,EAAA,EAAA,C,CAqCJ,IAAA,gBAAA,MAAA,WACE,IAAM,EAAa,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAA,CAArC,EAA6C,OAAA,EAAK,OAAO,E,GACnD,EAAc,KAAK,KAAK,CAAC,KAAK,MAAM,GAAK,EAAW,MAAM,EAEhE,OAAO,CAAU,CAAC,EAAY,AAChC,C,E,EA1CI,C,IA6CA,EAAN,WAAM,SAAA,EACQ,CAAY,CAAE,CAAC,CAAE,CAAC,EAD1B,EAAA,IAAA,CAAA,GAEF,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EAET,IAAM,EAAO,SAAS,aAAa,CAAC,OAEpC,EAAK,SAAS,CAAC,GAAG,CAAC,QACnB,EAAa,MAAM,CAAC,E,CARlB,OAAA,EAAA,EAAA,C,CAWJ,IAAA,WAAA,MAAA,SAAS,CAAI,EACX,EAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EAC7B,IAAI,CAAC,UAAU,CAAG,CACpB,C,E,CAEA,IAAA,aAAA,MAAA,WACE,IAAI,CAAC,UAAU,CAAG,IACpB,C,E,CAEA,IAAA,UAAA,MAAA,WACE,MAAO,CAAC,IAAI,CAAC,UAAU,AACzB,C,E,CAEA,IAAA,mBAAA,MAAA,SAAiB,CAAI,EACnB,EAAK,SAAS,CAAC,IAAI,CAAC,CAAC,CAAE,IAAI,CAAC,CAAC,EAC7B,IAAI,CAAC,kBAAkB,CAAG,CAC5B,C,E,CAEA,IAAA,kBAAA,MAAA,WACE,MAAO,CAAC,CAAC,IAAI,CAAC,kBAAkB,AAClC,C,E,CAEA,IAAA,YAAA,MAAA,SAAU,CAAO,EACf,OAAO,IAAI,CAAC,OAAO,IACb,CAAC,IAAI,CAAC,eAAe,IAAM,IAAI,CAAC,UAAU,CAAC,KAAK,GAAK,EAAQ,KAAK,AAC1E,C,E,CAEA,IAAA,aAAA,MAAA,WACE,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAC1C,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAEjC,GAAc,IAAI,CAAC,UAAU,CAAC,KAAK,CACnC,EAAM,WAAW,CAAG,EAEpB,IAAI,CAAC,kBAAkB,CAAC,aAAa,GACrC,IAAI,CAAC,kBAAkB,CAAG,IAC5B,C,E,EA/CI,C,IAkDA,EAAN,WAAM,SAAA,EACQ,CAAY,EADpB,EAAA,IAAA,CAAA,GAEF,IAAI,CAAC,IAAI,CAAG,SAAS,aAAa,CAAC,OACnC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAExB,IAAI,CAAC,QAAQ,CAAC,KAAK,MAAM,GAAK,GAAM,EAAI,GAExC,EAAa,MAAM,CAAC,IAAI,CAAC,IAAI,C,CAP3B,OAAA,EAAA,EAAA,C,CAUJ,IAAA,YAAA,MAAA,SAAU,CAAC,CAAE,CAAC,EACZ,IAAI,CAAC,CAAC,CAAG,EACT,IAAI,CAAC,CAAC,CAAG,EAET,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAO,GACnC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,MAAO,EACrC,C,E,CAEA,IAAA,WAAA,MAAA,SAAS,CAAK,EACZ,IAAI,CAAC,KAAK,CAAG,EACb,IAAI,CAAC,IAAI,CAAC,WAAW,CAAG,IAAI,CAAC,KAAK,CAElC,IAAM,EAAc,IAAM,AAAmB,EAAnB,KAAK,IAAI,CAAC,GAEpC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,iBAAkB,GAAe,MAAA,CAAZ,EAAY,MAE7D,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,mBACzB,GAA6B,MAAA,CAA3B,EAAc,GAAK,GAAK,GAAG,MAEb,OAAf,IAAI,CAAC,KAAK,EACZ,EAAW,SAAS,CAAC,MAAM,CAAC,SAEhC,C,E,CAEA,IAAA,gBAAA,MAAA,WACE,IAAI,CAAC,IAAI,CAAC,MAAM,EAClB,C,E,EApCI,C,IAuCA,EAAQ,IAAI,EAAM,GAIxB,SAAS,IACP,OAAO,gBAAgB,CAAC,UAAW,EAAa,CAAE,KAAM,CAAA,CAAK,EAC/D,CAEA,SAAS,EAAY,CAAC,EACpB,OAAQ,EAAE,GAAG,EACX,IAAK,UACH,GAAI,CAAC,IAAa,CAChB,IAEA,MACF,CAuDJ,EAAU,EAAM,oBAAoB,EApDhC,KAGF,KAAK,YACH,GAAI,CAAC,IAAe,CAClB,IAEA,MACF,CAgDJ,EAAU,EAAM,4BAA4B,EA7CxC,KAGF,KAAK,YACH,GAAI,CAAC,IAAe,CAClB,IAEA,MACF,CAyCJ,EAAU,EAAM,iBAAiB,EAtC7B,KAGF,KAAK,aACH,GAAI,CAAC,IAAgB,CACnB,IAEA,MACF,CAkCJ,EAAU,EAAM,yBAAyB,EA/BrC,KAGF,SACE,IAEA,MACJ,CAEA,EAAM,aAAa,GAAG,QAAQ,CAAC,IAAI,EAAK,IAEnC,KAAgB,KAAkB,KAAkB,KACvD,EAAY,SAAS,CAAC,MAAM,CAAC,UAG/B,GACF,CAkBA,SAAS,EAAU,CAAY,EAC7B,EAAa,OAAO,CAAC,SAAA,CAArB,EACE,IAAK,IAAI,EAAI,EAAG,EAAI,EAAM,MAAM,CAAE,IAChC,IAAI,CAAK,CAAC,EAAE,CAAC,OAAO,IASpB,IALA,IAAM,EAAe,CAAK,CAAC,EAAE,CAEzB,EAAA,KAAA,EACA,EAAI,EAAI,EAEL,GAAK,GAAK,CAAK,CAAC,EAAE,CAAC,SAAS,CAAC,EAAa,UAAU,GACzD,EAAa,CAAK,CAAC,EAAE,CACrB,IAGG,IAID,EAAW,OAAO,GACpB,EAAW,QAAQ,CAAC,EAAa,UAAU,EAE3C,EAAW,gBAAgB,CAAC,EAAa,UAAU,EAGrD,EAAa,UAAU,IAE3B,GAEA,EAAM,KAAK,CAAC,OAAO,CAAC,SAAA,CAApB,EACE,EAAK,eAAe,IAAM,EAAK,UAAU,EAC3C,EACF,CAEA,SAAS,IACP,OAAO,EAAQ,EAAM,oBAAoB,CAC3C,CAEA,SAAS,IACP,OAAO,EAAQ,EAAM,4BAA4B,CACnD,CAEA,SAAS,IACP,OAAO,EAAQ,EAAM,iBAAiB,CACxC,CAEA,SAAS,IACP,OAAO,EAAQ,EAAM,yBAAyB,CAChD,CAEA,SAAS,EAAQ,CAAY,EAC3B,OAAO,EAAa,IAAI,CAAC,SAAA,CAAzB,EAAkC,OAI3B,AAJ0C,EAIpC,IAAI,CAAC,SAAC,CAAA,CAAM,CAAzB,QACE,CAAI,CAAA,AAAM,IAAN,GAAW,EAAK,OAAO,EAAA,GAMpB,AAFY,AAT4B,CASvB,CAAC,EAAI,EAAE,CAEb,SAAS,CAAC,EAAK,UAAU,CAC7C,E,EAXF,CAzIA","sources":["<anon>","src/scripts/main.js"],"sourcesContent":["\"use strict\";\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nvar score = document.querySelector(\".game_score\");\nvar buttonStart = document.querySelector(\".start\");\nvar gameBoard = document.querySelector(\".game_board\");\nvar messageWin = document.querySelector(\".message_win\");\nvar messageLose = document.querySelector(\".message_lose\");\nvar messageStart = document.querySelector(\".message_start\");\nvar BOARD_SIZE = 4;\nvar CELL_COUNT = BOARD_SIZE * BOARD_SIZE;\nvar scoreValue = 0;\nbuttonStart.addEventListener(\"click\", function() {\n    if (buttonStart.classList.contains(\"start\")) {\n        buttonStart.classList.remove(\"start\");\n        buttonStart.classList.add(\"restart\");\n        buttonStart.textContent = \"Restart\";\n        messageStart.classList.add(\"hidden\");\n        messageWin.classList.add(\"hidden\");\n        messageLose.classList.add(\"hidden\");\n    }\n    board.cells.forEach(function(cell) {\n        if (!cell.isEmpty()) {\n            cell.linkedTile.removeElement();\n            cell.unlinkTile();\n        }\n        score.textContent = 0;\n    });\n    board.findEmptyCell().linkTile(new Tile(gameBoard));\n    board.findEmptyCell().linkTile(new Tile(gameBoard));\n});\nvar Board = /*#__PURE__*/ function() {\n    function Board(boardElement) {\n        _class_call_check(this, Board);\n        this.cells = [];\n        for(var i = 0; i < CELL_COUNT; i++)this.cells.push(new Cell(boardElement, i % BOARD_SIZE, Math.floor(i / BOARD_SIZE)));\n        this.cellsGroupedByColumn = this.cells.reduce(function(groupCells, cell) {\n            groupCells[cell.x] = groupCells[cell.x] || [];\n            groupCells[cell.x][cell.y] = cell;\n            return groupCells;\n        }, []);\n        this.cellsGroupedByReversedColumn = this.cellsGroupedByColumn.map(function(column) {\n            return _to_consumable_array(column).reverse();\n        });\n        this.cellsGroupedByRow = this.cells.reduce(function(groupCells, cell) {\n            groupCells[cell.y] = groupCells[cell.y] || [];\n            groupCells[cell.y][cell.x] = cell;\n            return groupCells;\n        }, []);\n        this.cellsGroupedByReversedRow = this.cellsGroupedByRow.map(function(row) {\n            return _to_consumable_array(row).reverse();\n        });\n    }\n    _create_class(Board, [\n        {\n            key: \"findEmptyCell\",\n            value: function findEmptyCell() {\n                var emptyCells = this.cells.filter(function(cell) {\n                    return cell.isEmpty();\n                });\n                var randomIndex = Math.floor(Math.random() * emptyCells.length);\n                return emptyCells[randomIndex];\n            }\n        }\n    ]);\n    return Board;\n}();\nvar Cell = /*#__PURE__*/ function() {\n    function Cell(boardElement, x, y) {\n        _class_call_check(this, Cell);\n        this.x = x;\n        this.y = y;\n        var cell = document.createElement(\"div\");\n        cell.classList.add(\"cell\");\n        boardElement.append(cell);\n    }\n    _create_class(Cell, [\n        {\n            key: \"linkTile\",\n            value: function linkTile(tile) {\n                tile.setCoords(this.x, this.y);\n                this.linkedTile = tile;\n            }\n        },\n        {\n            key: \"unlinkTile\",\n            value: function unlinkTile() {\n                this.linkedTile = null;\n            }\n        },\n        {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n                return !this.linkedTile;\n            }\n        },\n        {\n            key: \"linkTileForMerge\",\n            value: function linkTileForMerge(tile) {\n                tile.setCoords(this.x, this.y);\n                this.linkedTileForMerge = tile;\n            }\n        },\n        {\n            key: \"hasTileForMerge\",\n            value: function hasTileForMerge() {\n                return !!this.linkedTileForMerge;\n            }\n        },\n        {\n            key: \"canAccept\",\n            value: function canAccept(newTile) {\n                return this.isEmpty() || !this.hasTileForMerge() && this.linkedTile.value === newTile.value;\n            }\n        },\n        {\n            key: \"mergeTiles\",\n            value: function mergeTiles() {\n                this.linkedTile.setValue(this.linkedTile.value + this.linkedTileForMerge.value);\n                scoreValue += this.linkedTile.value;\n                score.textContent = scoreValue;\n                this.linkedTileForMerge.removeElement();\n                this.linkedTileForMerge = null;\n            }\n        }\n    ]);\n    return Cell;\n}();\nvar Tile = /*#__PURE__*/ function() {\n    function Tile(boardElement) {\n        _class_call_check(this, Tile);\n        this.tile = document.createElement(\"div\");\n        this.tile.classList.add(\"tile\");\n        this.setValue(Math.random() > 0.1 ? 2 : 4);\n        boardElement.append(this.tile);\n    }\n    _create_class(Tile, [\n        {\n            key: \"setCoords\",\n            value: function setCoords(x, y) {\n                this.x = x;\n                this.y = y;\n                this.tile.style.setProperty(\"--x\", x);\n                this.tile.style.setProperty(\"--y\", y);\n            }\n        },\n        {\n            key: \"setValue\",\n            value: function setValue(value) {\n                this.value = value;\n                this.tile.textContent = this.value;\n                var bgLightness = 100 - Math.log2(value) * 8;\n                this.tile.style.setProperty(\"--bg-lightness\", \"\".concat(bgLightness, \"%\"));\n                this.tile.style.setProperty(\"--text-lightness\", \"\".concat(bgLightness < 40 ? 80 : 20, \"%\"));\n                if (this.value === 2048) messageWin.classList.remove(\"hidden\");\n            }\n        },\n        {\n            key: \"removeElement\",\n            value: function removeElement() {\n                this.tile.remove();\n            }\n        }\n    ]);\n    return Tile;\n}();\nvar board = new Board(gameBoard);\nsetupInput();\nfunction setupInput() {\n    window.addEventListener(\"keydown\", handleInput, {\n        once: true\n    });\n}\nfunction handleInput(e) {\n    switch(e.key){\n        case \"ArrowUp\":\n            if (!canMoveUp()) {\n                setupInput();\n                return;\n            }\n            moveUp();\n            break;\n        case \"ArrowDown\":\n            if (!canMoveDown()) {\n                setupInput();\n                return;\n            }\n            moveDown();\n            break;\n        case \"ArrowLeft\":\n            if (!canMoveLeft()) {\n                setupInput();\n                return;\n            }\n            moveLeft();\n            break;\n        case \"ArrowRight\":\n            if (!canMoveRight()) {\n                setupInput();\n                return;\n            }\n            moveRight();\n            break;\n        default:\n            setupInput();\n            return;\n    }\n    board.findEmptyCell().linkTile(new Tile(gameBoard));\n    if (!canMoveUp() && !canMoveDown() && !canMoveLeft() && !canMoveRight()) messageLose.classList.remove(\"hidden\");\n    setupInput();\n}\nfunction moveUp() {\n    moveTiles(board.cellsGroupedByColumn);\n}\nfunction moveDown() {\n    moveTiles(board.cellsGroupedByReversedColumn);\n}\nfunction moveLeft() {\n    moveTiles(board.cellsGroupedByRow);\n}\nfunction moveRight() {\n    moveTiles(board.cellsGroupedByReversedRow);\n}\nfunction moveTiles(groupedCells) {\n    groupedCells.forEach(function(group) {\n        for(var i = 1; i < group.length; i++){\n            if (group[i].isEmpty()) continue;\n            var cellWithTile = group[i];\n            var targetCell = void 0;\n            var j = i - 1;\n            while(j >= 0 && group[j].canAccept(cellWithTile.linkedTile)){\n                targetCell = group[j];\n                j--;\n            }\n            if (!targetCell) continue;\n            if (targetCell.isEmpty()) targetCell.linkTile(cellWithTile.linkedTile);\n            else targetCell.linkTileForMerge(cellWithTile.linkedTile);\n            cellWithTile.unlinkTile();\n        }\n    });\n    board.cells.forEach(function(cell) {\n        cell.hasTileForMerge() && cell.mergeTiles();\n    });\n}\nfunction canMoveUp() {\n    return canMove(board.cellsGroupedByColumn);\n}\nfunction canMoveDown() {\n    return canMove(board.cellsGroupedByReversedColumn);\n}\nfunction canMoveLeft() {\n    return canMove(board.cellsGroupedByRow);\n}\nfunction canMoveRight() {\n    return canMove(board.cellsGroupedByReversedRow);\n}\nfunction canMove(groupedCells) {\n    return groupedCells.some(function(group) {\n        return canMoveInGroup(group);\n    });\n}\nfunction canMoveInGroup(group) {\n    return group.some(function(cell, i) {\n        if (i === 0 || cell.isEmpty()) return false;\n        var targetCell = group[i - 1];\n        return targetCell.canAccept(cell.linkedTile);\n    });\n}\n\n//# sourceMappingURL=index.5d97fe57.js.map\n","'use strict';\n\nconst score = document.querySelector('.game_score');\nconst buttonStart = document.querySelector('.start');\nconst gameBoard = document.querySelector('.game_board');\nconst messageWin = document.querySelector('.message_win');\nconst messageLose = document.querySelector('.message_lose');\nconst messageStart = document.querySelector('.message_start');\nconst BOARD_SIZE = 4;\nconst CELL_COUNT = BOARD_SIZE * BOARD_SIZE;\nlet scoreValue = 0;\n\nbuttonStart.addEventListener('click', () => {\n  if (buttonStart.classList.contains('start')) {\n    buttonStart.classList.remove('start');\n    buttonStart.classList.add('restart');\n    buttonStart.textContent = 'Restart';\n    messageStart.classList.add('hidden');\n    messageWin.classList.add('hidden');\n    messageLose.classList.add('hidden');\n  }\n\n  board.cells.forEach(cell => {\n    if (!cell.isEmpty()) {\n      cell.linkedTile.removeElement();\n      cell.unlinkTile();\n    }\n\n    score.textContent = 0;\n  });\n\n  board.findEmptyCell().linkTile(new Tile(gameBoard));\n  board.findEmptyCell().linkTile(new Tile(gameBoard));\n});\n\nclass Board {\n  constructor(boardElement) {\n    this.cells = [];\n\n    for (let i = 0; i < CELL_COUNT; i++) {\n      this.cells.push(\n        new Cell(\n          boardElement,\n          i % BOARD_SIZE,\n          Math.floor(i / BOARD_SIZE)\n        )\n      );\n    }\n\n    this.cellsGroupedByColumn = this.cells.reduce((groupCells, cell) => {\n      groupCells[cell.x] = groupCells[cell.x] || [];\n      groupCells[cell.x][cell.y] = cell;\n\n      return groupCells;\n    }, []);\n\n    this.cellsGroupedByReversedColumn = this.cellsGroupedByColumn.map(\n      column => [...column].reverse()\n    );\n\n    this.cellsGroupedByRow = this.cells.reduce((groupCells, cell) => {\n      groupCells[cell.y] = groupCells[cell.y] || [];\n      groupCells[cell.y][cell.x] = cell;\n\n      return groupCells;\n    }, []);\n\n    this.cellsGroupedByReversedRow = this.cellsGroupedByRow.map(\n      row => [...row].reverse()\n    );\n  }\n\n  findEmptyCell() {\n    const emptyCells = this.cells.filter(cell => cell.isEmpty());\n    const randomIndex = Math.floor(Math.random() * emptyCells.length);\n\n    return emptyCells[randomIndex];\n  }\n}\n\nclass Cell {\n  constructor(boardElement, x, y) {\n    this.x = x;\n    this.y = y;\n\n    const cell = document.createElement('div');\n\n    cell.classList.add('cell');\n    boardElement.append(cell);\n  }\n\n  linkTile(tile) {\n    tile.setCoords(this.x, this.y);\n    this.linkedTile = tile;\n  }\n\n  unlinkTile() {\n    this.linkedTile = null;\n  }\n\n  isEmpty() {\n    return !this.linkedTile;\n  }\n\n  linkTileForMerge(tile) {\n    tile.setCoords(this.x, this.y);\n    this.linkedTileForMerge = tile;\n  }\n\n  hasTileForMerge() {\n    return !!this.linkedTileForMerge;\n  }\n\n  canAccept(newTile) {\n    return this.isEmpty()\n      || (!this.hasTileForMerge() && this.linkedTile.value === newTile.value);\n  }\n\n  mergeTiles() {\n    this.linkedTile.setValue(this.linkedTile.value\n      + this.linkedTileForMerge.value);\n\n    scoreValue += this.linkedTile.value;\n    score.textContent = scoreValue;\n\n    this.linkedTileForMerge.removeElement();\n    this.linkedTileForMerge = null;\n  }\n}\n\nclass Tile {\n  constructor(boardElement) {\n    this.tile = document.createElement('div');\n    this.tile.classList.add('tile');\n\n    this.setValue(Math.random() > 0.1 ? 2 : 4);\n\n    boardElement.append(this.tile);\n  }\n\n  setCoords(x, y) {\n    this.x = x;\n    this.y = y;\n\n    this.tile.style.setProperty('--x', x);\n    this.tile.style.setProperty('--y', y);\n  }\n\n  setValue(value) {\n    this.value = value;\n    this.tile.textContent = this.value;\n\n    const bgLightness = 100 - Math.log2(value) * 8;\n\n    this.tile.style.setProperty('--bg-lightness', `${bgLightness}%`);\n\n    this.tile.style.setProperty('--text-lightness',\n      `${bgLightness < 40 ? 80 : 20}%`);\n\n    if (this.value === 2048) {\n      messageWin.classList.remove('hidden');\n    }\n  }\n\n  removeElement() {\n    this.tile.remove();\n  }\n}\n\nconst board = new Board(gameBoard);\n\nsetupInput();\n\nfunction setupInput() {\n  window.addEventListener('keydown', handleInput, { once: true });\n}\n\nfunction handleInput(e) {\n  switch (e.key) {\n    case 'ArrowUp': {\n      if (!canMoveUp()) {\n        setupInput();\n\n        return;\n      }\n\n      moveUp();\n      break;\n    }\n\n    case 'ArrowDown': {\n      if (!canMoveDown()) {\n        setupInput();\n\n        return;\n      }\n\n      moveDown();\n      break;\n    }\n\n    case 'ArrowLeft': {\n      if (!canMoveLeft()) {\n        setupInput();\n\n        return;\n      }\n\n      moveLeft();\n      break;\n    }\n\n    case 'ArrowRight': {\n      if (!canMoveRight()) {\n        setupInput();\n\n        return;\n      }\n\n      moveRight();\n      break;\n    }\n\n    default:\n      setupInput();\n\n      return;\n  }\n\n  board.findEmptyCell().linkTile(new Tile(gameBoard));\n\n  if (!canMoveUp() && !canMoveDown() && !canMoveLeft() && !canMoveRight()) {\n    messageLose.classList.remove('hidden');\n  }\n\n  setupInput();\n}\n\nfunction moveUp() {\n  moveTiles(board.cellsGroupedByColumn);\n}\n\nfunction moveDown() {\n  moveTiles(board.cellsGroupedByReversedColumn);\n}\n\nfunction moveLeft() {\n  moveTiles(board.cellsGroupedByRow);\n}\n\nfunction moveRight() {\n  moveTiles(board.cellsGroupedByReversedRow);\n}\n\nfunction moveTiles(groupedCells) {\n  groupedCells.forEach(group => {\n    for (let i = 1; i < group.length; i++) {\n      if (group[i].isEmpty()) {\n        continue;\n      }\n\n      const cellWithTile = group[i];\n\n      let targetCell;\n      let j = i - 1;\n\n      while (j >= 0 && group[j].canAccept(cellWithTile.linkedTile)) {\n        targetCell = group[j];\n        j--;\n      }\n\n      if (!targetCell) {\n        continue;\n      }\n\n      if (targetCell.isEmpty()) {\n        targetCell.linkTile(cellWithTile.linkedTile);\n      } else {\n        targetCell.linkTileForMerge(cellWithTile.linkedTile);\n      }\n\n      cellWithTile.unlinkTile();\n    }\n  });\n\n  board.cells.forEach(cell => {\n    cell.hasTileForMerge() && cell.mergeTiles();\n  });\n}\n\nfunction canMoveUp() {\n  return canMove(board.cellsGroupedByColumn);\n}\n\nfunction canMoveDown() {\n  return canMove(board.cellsGroupedByReversedColumn);\n}\n\nfunction canMoveLeft() {\n  return canMove(board.cellsGroupedByRow);\n}\n\nfunction canMoveRight() {\n  return canMove(board.cellsGroupedByReversedRow);\n}\n\nfunction canMove(groupedCells) {\n  return groupedCells.some(group => canMoveInGroup(group));\n}\n\nfunction canMoveInGroup(group) {\n  return group.some((cell, i) => {\n    if (i === 0 || cell.isEmpty()) {\n      return false;\n    }\n\n    const targetCell = group[i - 1];\n\n    return targetCell.canAccept(cell.linkedTile);\n  });\n}\n"],"names":["_array_like_to_array","arr","len","length","i","arr2","Array","_class_call_check","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_create_class","protoProps","staticProps","prototype","_to_consumable_array","_array_without_holes","isArray","_iterable_to_array","iter","Symbol","iterator","from","_unsupported_iterable_to_array","o","minLen","n","toString","call","slice","constructor","name","test","_non_iterable_spread","score","document","querySelector","buttonStart","gameBoard","messageWin","messageLose","messageStart","scoreValue","addEventListener","classList","contains","remove","add","textContent","board","cells","forEach","cell","isEmpty","linkedTile","removeElement","unlinkTile","findEmptyCell","linkTile","Tile","Board","boardElement","BOARD_SIZE","push","Cell","Math","floor","cellsGroupedByColumn","reduce","groupCells","x","y","cellsGroupedByReversedColumn","map","column","reverse","cellsGroupedByRow","cellsGroupedByReversedRow","row","value","emptyCells","filter","randomIndex","random","createElement","append","tile","setCoords","linkedTileForMerge","newTile","hasTileForMerge","setValue","style","setProperty","bgLightness","log2","concat","setupInput","window","handleInput","once","e","canMoveUp","moveTiles","canMoveDown","canMoveLeft","canMoveRight","groupedCells","group","cellWithTile","targetCell","j","canAccept","linkTileForMerge","mergeTiles","canMove","some"],"version":3,"file":"index.5d97fe57.js.map"}